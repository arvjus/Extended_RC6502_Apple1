
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -D RESET=WOZMON --m6502 --nostart --output apple1.bin --list apple1.lst apple1.asm
; Sat Apr 26 22:24:13 2025

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$ff00					RESET=WOZMON

;******  Processing input file: apple1.asm


;******  Processing file: bss.asm

>0000					buffer:             .fill 32        ; command / FileEntry
=$02					buff_fe_start = buffer+2
=$04					buff_fe_size = buffer+4
>0020					prg_start:          .addr ?         ; write, jmp_prg
>0022					prg_stop:           .addr ?         ; calculated address
>002d					ptr:                .addr ?         ; print_msg, read, write
>002f					flag:               .byte ?         ; flag to control execution, prg storing, loading
>0030					prefix:             .fill 12
>003c					dat_mask:           .byte ?         ; value contains DAT bit
>003d					ms_nibble:          .byte ?         ; store nibble temporary
>003e					tmp_buffer:         .fill 11        ; variables used by conversion functions
>004a					lomem:              .addr ?         ; BASIC program location
>004c					himem:              .addr ?

;******  Return to file: apple1.asm


;******  Processing file: fdsh/fdsh.asm

=1					REAL_HW = 1
=0					MOCK_HW = 0
=0					DEBUG = 0       ; 1=Show traces in data exchange
="1.0"					VERSION = "1.0"
.f000					FDSH:
.f000	d8		cld		    cld             ; Clear decimal arithmetic mode.
.f001	58		cli		    cli
.f002	a0 7f		ldy #$7f	    ldy #$7F        ; Mask for DSP data direction register.
.f004	8c 12 d0	sty $d012	    sty DSP         ; Set it up.
.f007	a9 a7		lda #$a7	    lda #$A7        ; KBD and DSP control register mask.
.f009	8d 11 d0	sta $d011	    sta KBDCR       ; Enable interrupts, set CA1, CB1, for
.f00c	8d 13 d0	sta $d013	    sta DSPCR       ; positive edge sense/output mode.
.f00f	a2 ff		ldx #$ff	    ldx #$ff        ; Initialize stack pointer
.f011	9a		txs		    txs
.f012	4c e3 f5	jmp $f5e3	    jmp fdsh_init

;******  Processing file: fdsh/defs.asm

=$08					BS  = $08
=$0d					CR  = $0D
=$1b					ESC = $1B
=$c800					DEVICE_IN   = $C800
=$c801					DEVICE_OUT  = $C801
=$01					CMD_LIST    = $01
=$02					CMD_READ    = $02
=$03					CMD_WRITE   = $03
=$04					CMD_DELETE  = $04
=$a0					ACK         = $A0
=$af					NACK        = $AF
=$80					BODT        = $80       ; Begin of data transfer marker
=$8f					EODT        = $8F       ; End of data transfer marker
=$80					RDY         = %10000000
=$40					BSY         = %01000000
=$10					DAT         = %00010000
=0					ST_RESET    = 0
=1					ST_WIP      = 1
=2					ST_DONE     = 2
=3					ST_ABORT    = 3
=4					ST_ERROR    = 4

;******  Return to file: fdsh/fdsh.asm


;******  Processing file: fdsh/delay.asm

.f015					wait:
.f015	38		sec		    sec
.f016					wait2:
.f016	48		pha		    pha
.f017					wait3:
.f017	e9 01		sbc #$01	    sbc   #$01
.f019	d0 fc		bne $f017	    bne   wait3
.f01b	68		pla		    pla                ; (13+27/2*a+5/2*a*a)
.f01c	e9 01		sbc #$01	    sbc   #$01
.f01e	d0 f6		bne $f016	    bne   wait2
.f020	60		rts		    rts
.f021					delay_long:
.f021	48		pha		    pha
.f022	a9 ff		lda #$ff	    lda #$ff            ; 166ms
.f024	20 15 f0	jsr $f015	    jsr wait
.f027	68		pla		    pla
.f028	60		rts		    rts
.f029					delay_short:
.f029	48		pha		    pha
.f02a	a9 12		lda #$12	    lda #$12            ; 1ms
.f02c	20 15 f0	jsr $f015	    jsr wait
.f02f	68		pla		    pla
.f030	60		rts		    rts

;******  Return to file: fdsh/fdsh.asm


;******  Processing file: fdsh/common.asm

.f031					print_msg:
.f031	a0 00		ldy #$00	    ldy #0
.f033					print_msg_loop:
.f033	b1 2d		lda ($2d),y	    lda (ptr), y
.f035	f0 07		beq $f03e	    beq print_msg_done
.f037	20 ef ff	jsr $ffef	    jsr ECHO
.f03a	c8		iny		    iny
.f03b	4c 33 f0	jmp $f033	    jmp print_msg_loop
.f03e					print_msg_done:
.f03e	60		rts		    rts
.f03f					print_buffer:
.f03f	a2 00		ldx #$00	    ldx #0
.f041					print_buffer_loop:
.f041	b5 00		lda $00,x	    lda buffer, x
.f043	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f046	a9 20		lda #$20	    lda #' '
.f048	20 ef ff	jsr $ffef	    jsr ECHO
.f04b	e8		inx		    inx
.f04c	e0 20		cpx #$20	    cpx #32
.f04e	d0 f1		bne $f041	    bne print_buffer_loop
.f050	60		rts		    rts
.f051					hex_to_bin:
.f051	c9 30		cmp #$30	    cmp #$30            ; '0'
.f053	90 14		bcc $f069	    bcc invalid_hex
.f055	c9 3a		cmp #$3a	    cmp #$3a            ; '9' + 1
.f057	90 0c		bcc $f065	    bcc is_digit
.f059	c9 41		cmp #$41	    cmp #$41            ; 'A'
.f05b	90 0c		bcc $f069	    bcc invalid_hex
.f05d	c9 47		cmp #$47	    cmp #$47            ; 'F' + 1
.f05f	b0 08		bcs $f069	    bcs invalid_hex
.f061	38		sec		    sec                 ; Set carry before SBC
.f062	e9 37		sbc #$37	    sbc #$37            ; convert 'A'-'F' -> 10-15
.f064	60		rts		    rts
.f065					is_digit:
.f065	38		sec		    sec                 ; Set carry before SBC
.f066	e9 30		sbc #$30	    sbc #$30            ; convert '0'-'9' -> 0-9
.f068	60		rts		    rts
.f069					invalid_hex:
.f069	a9 00		lda #$00	    lda #$00            ; return 0 if invalid
.f06b	60		rts		    rts
.f06c					calc_prg_stop:
.f06c	18		clc		    clc
.f06d	a5 02		lda $02		    lda buff_fe_start   ; start low
.f06f	65 04		adc $04		    adc buff_fe_size    ; size low
.f071	85 22		sta $22		    sta prg_stop        ; stop low
.f073	a5 03		lda $03		    lda buff_fe_start+1 ; start high
.f075	65 05		adc $05		    adc buff_fe_size+1  ; size high
.f077	85 23		sta $23		    sta prg_stop+1      ; stop high
.f079	60		rts		    rts
.f07a					receive_byte:
.f07a	a0 ff		ldy #$ff	    ldy #$ff
.f07c					receive_byte_load:
.f07c	ad 00 c8	lda $c800	    lda DEVICE_IN       ; Valid only if RDY is set
.f07f	30 0b		bmi $f08c	    bmi received_byte
.f081	88		dey		    dey
.f082	f0 0a		beq $f08e	    beq receive_byte_err
.f084	a9 0c		lda #$0c	    lda #$0c            ; 500uS
.f086	20 15 f0	jsr $f015	    jsr WAIT
.f089	4c 7c f0	jmp $f07c	    jmp receive_byte_load
.f08c					received_byte:
.f08c	18		clc		    clc
.f08d	60		rts		    rts
.f08e					receive_byte_err:
.f08e	38		sec		    sec
.f08f	60		rts		    rts
.f090					receive_data_byte:
.f090	20 7a f0	jsr $f07a	    jsr receive_byte
.f093	b0 2c		bcs $f0c1	    bcs receive_data_byte_err   ; timeout
.f095	c9 af		cmp #$af	    cmp #NACK
.f097	f0 25		beq $f0be	    beq receive_data_byte_done
.f099	20 fa f0	jsr $f0fa	    jsr send_ack                ; ACK
.f09c	c9 8f		cmp #$8f	    cmp #EODT
.f09e	f0 1e		beq $f0be	    beq receive_data_byte_done  ; end of data
.f0a0	24 3c		bit $3c		    bit dat_mask
.f0a2	f0 1a		beq $f0be	    beq receive_data_byte_done  ; binary is not expected
.f0a4	29 0f		and #$0f	    and #$0F                    ; it's a MS nibble
.f0a6	0a		asl a		    asl
.f0a7	0a		asl a		    asl
.f0a8	0a		asl a		    asl
.f0a9	0a		asl a		    asl
.f0aa	85 3d		sta $3d		    sta ms_nibble               ; store to ZP
.f0ac	20 7a f0	jsr $f07a	    jsr receive_byte            ; get another half
.f0af	b0 10		bcs $f0c1	    bcs receive_data_byte_err   ; timeout
.f0b1	c9 af		cmp #$af	    cmp #NACK
.f0b3	f0 09		beq $f0be	    beq receive_data_byte_done
.f0b5	20 fa f0	jsr $f0fa	    jsr send_ack                ; ACK
.f0b8	29 0f		and #$0f	    and #$0F
.f0ba	05 3d		ora $3d		    ora ms_nibble
.f0bc	18		clc		    clc                         ; success
.f0bd	60		rts		    rts
.f0be					receive_data_byte_done:
.f0be	a9 02		lda #$02	    lda #ST_DONE
.f0c0	60		rts		    rts
.f0c1					receive_data_byte_err:
.f0c1	a9 04		lda #$04	    lda #ST_ERROR
.f0c3	60		rts		    rts
.f0c4					send_byte:
.f0c4	a0 ff		ldy #$ff	    ldy #$ff
.f0c6	48		pha		    pha
.f0c7					wait_not_bsy:
.f0c7	ad 00 c8	lda $c800	    lda DEVICE_IN
.f0ca	29 40		and #$40	    and #BSY
.f0cc	f0 09		beq $f0d7	    beq not_bsy
.f0ce	88		dey		    dey
.f0cf	f0 0f		beq $f0e0	    beq send_byte_err
.f0d1	20 29 f0	jsr $f029	    jsr delay_short
.f0d4	4c c7 f0	jmp $f0c7	    jmp wait_not_bsy
.f0d7					not_bsy:
.f0d7	20 29 f0	jsr $f029	    jsr delay_short
.f0da	68		pla		    pla
.f0db	8d 01 c8	sta $c801	    sta DEVICE_OUT
.f0de					send_byte_done:
.f0de	18		clc		    clc
.f0df	60		rts		    rts
.f0e0					send_byte_err:
.f0e0	38		sec		    sec
.f0e1	60		rts		    rts
.f0e2					send_data_byte:
.f0e2	48		pha		    pha         ; MS nibble
.f0e3	4a		lsr a		    lsr
.f0e4	4a		lsr a		    lsr
.f0e5	4a		lsr a		    lsr
.f0e6	4a		lsr a		    lsr
.f0e7	09 10		ora #$10	    ora #DAT
.f0e9	20 c4 f0	jsr $f0c4	    jsr send_byte
.f0ec	b0 0a		bcs $f0f8	    bcs send_data_byte_err
.f0ee	68		pla		    pla         ; LS nibble
.f0ef	29 0f		and #$0f	    and #$0F
.f0f1	09 10		ora #$10	    ora #DAT
.f0f3	20 c4 f0	jsr $f0c4	    jsr send_byte
.f0f6	18		clc		    clc
.f0f7	60		rts		    rts
.f0f8					send_data_byte_err:
.f0f8	68		pla		    pla
.f0f9	60		rts		    rts
.f0fa					send_ack:
.f0fa	48		pha		    pha
.f0fb	a9 a0		lda #$a0	    lda #ACK
.f0fd	20 c4 f0	jsr $f0c4	    jsr send_byte
.f100	68		pla		    pla
.f101	60		rts		    rts
.f102					send_request:
.f102	20 c4 f0	jsr $f0c4	    jsr send_byte
.f105	b0 67		bcs $f16e	    bcs send_request_err    ; timeout
.f107	20 7a f0	jsr $f07a	    jsr receive_byte        ; ACK is expected
.f10a	b0 62		bcs $f16e	    bcs send_request_err    ; timeout
.f10c	c9 af		cmp #$af	    cmp #NACK
.f10e	f0 5a		beq $f16a	    beq send_request_done
.f110	a9 80		lda #$80	    lda #BODT
.f112	20 c4 f0	jsr $f0c4	    jsr send_byte
.f115	b0 57		bcs $f16e	    bcs send_request_err    ; timeout
.f117	20 7a f0	jsr $f07a	    jsr receive_byte        ; ACK is expected
.f11a	b0 52		bcs $f16e	    bcs send_request_err    ; timeout
.f11c	c9 af		cmp #$af	    cmp #NACK
.f11e	f0 4a		beq $f16a	    beq send_request_done
.f120	a2 03		ldx #$03	    ldx #3                  ; skip "XX "
.f122	b5 00		lda $00,x	    lda buffer, x
.f124	c9 23		cmp #$23	    cmp #'#'                ; block id start
.f126	f0 13		beq $f13b	    beq send_request_args   ; don't prefix block id
.f128	a2 00		ldx #$00	    ldx #0
.f12a	b5 30		lda $30,x	    lda prefix, x
.f12c	f0 0d		beq $f13b	    beq send_request_args   ; empty prefix
.f12e					send_request_prefix:
.f12e	b5 30		lda $30,x	    lda prefix, x
.f130	f0 09		beq $f13b	    beq send_request_args
.f132	20 e2 f0	jsr $f0e2	    jsr send_data_byte
.f135	b0 37		bcs $f16e	    bcs send_request_err    ; timeout
.f137	e8		inx		    inx
.f138	4c 2e f1	jmp $f12e	    jmp send_request_prefix;
.f13b					send_request_args:
.f13b	a2 03		ldx #$03	    ldx #3
.f13d					send_request_arg:
.f13d	b5 00		lda $00,x	    lda buffer, x
.f13f	f0 09		beq $f14a	    beq send_request_eodt
.f141	20 e2 f0	jsr $f0e2	    jsr send_data_byte
.f144	b0 28		bcs $f16e	    bcs send_request_err    ; timeout
.f146	e8		inx		    inx
.f147	4c 3d f1	jmp $f13d	    jmp send_request_arg;
.f14a					send_request_eodt:
.f14a	a9 8f		lda #$8f	    lda #EODT
.f14c	20 c4 f0	jsr $f0c4	    jsr send_byte
.f14f	b0 1d		bcs $f16e	    bcs send_request_err    ; timeout
.f151	20 21 f0	jsr $f021	    jsr delay_long
.f154	20 7a f0	jsr $f07a	    jsr receive_byte        ; ACK. BODT or EODT is expected
.f157	b0 15		bcs $f16e	    bcs send_request_err    ; timeout
.f159	c9 af		cmp #$af	    cmp #NACK
.f15b	f0 11		beq $f16e	    beq send_request_err
.f15d	c9 8f		cmp #$8f	    cmp #EODT
.f15f	f0 09		beq $f16a	    beq send_request_done   ; end of data
.f161	c9 a0		cmp #$a0	    cmp #ACK                ; it must be CMD_WRITE
.f163	f0 03		beq $f168	    beq send_no_ack         ; don't ACK on ACK
.f165	20 fa f0	jsr $f0fa	    jsr send_ack            ; ACK
.f168					send_no_ack:
.f168	18		clc		    clc                     ; success
.f169	60		rts		    rts
.f16a					send_request_done:
.f16a	a9 02		lda #$02	    lda #ST_DONE
.f16c	18		clc		    clc
.f16d	60		rts		    rts
.f16e					send_request_err:
.f16e	a9 04		lda #$04	    lda #ST_ERROR
.f170	38		sec		    sec
.f171	60		rts		    rts

;******  Return to file: fdsh/fdsh.asm


;******  Processing file: fdsh/list.asm

.f172					list:
.f172	a9 01		lda #$01	    lda #CMD_LIST
.f174	20 02 f1	jsr $f102	    jsr send_request
.f177	90 08		bcc $f181	    bcc list_request_ok     ; ok, continue
.f179	c9 02		cmp #$02	    cmp #ST_DONE
.f17b	f0 26		beq $f1a3	    beq list_done
.f17d	c9 04		cmp #$04	    cmp #ST_ERROR
.f17f	f0 23		beq $f1a4	    beq list_err
.f181					list_request_ok:
.f181	c9 80		cmp #$80	    cmp #BODT
.f183	d0 1e		bne $f1a3	    bne list_done           ; nope, no data
.f185					list_fileentry:
.f185	a2 00		ldx #$00	    ldx #0
.f187					list_fileentry_byte:
.f187	20 90 f0	jsr $f090	    jsr receive_data_byte
.f18a	90 08		bcc $f194	    bcc list_fileentry_store ; ok, continue
.f18c	c9 02		cmp #$02	    cmp #ST_DONE
.f18e	f0 13		beq $f1a3	    beq list_done
.f190	c9 04		cmp #$04	    cmp #ST_ERROR
.f192	f0 10		beq $f1a4	    beq list_err
.f194					list_fileentry_store:
.f194	95 00		sta $00,x	    sta buffer, x
.f196	e8		inx		    inx
.f197	e0 20		cpx #$20	    cpx #32
.f199	d0 ec		bne $f187	    bne list_fileentry_byte
.f19b	20 aa f1	jsr $f1aa	    jsr list_print_fileentry
.f19e	20 c9 fa	jsr $fac9	    jsr KBDIN_NOWAIT        ; 0 in A if no key pressed
.f1a1	f0 e2		beq $f185	    beq list_fileentry      ; next file entry
.f1a3					list_done:
.f1a3	60		rts		    rts
.f1a4					list_err:
.f1a4	a9 21		lda #$21	    lda #'!'
.f1a6	20 ef ff	jsr $ffef	    jsr ECHO
.f1a9	60		rts		    rts
.f1aa					list_print_fileentry:
.f1aa	a5 03		lda $03		    lda buff_fe_start+1 ; start high
.f1ac	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f1af	a5 02		lda $02		    lda buff_fe_start   ; start low
.f1b1	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f1b4	a9 20		lda #$20	    lda #' '
.f1b6	20 ef ff	jsr $ffef	    jsr ECHO
.f1b9	a9 2d		lda #$2d	    lda #'-'
.f1bb	20 ef ff	jsr $ffef	    jsr ECHO
.f1be	a9 20		lda #$20	    lda #' '
.f1c0	20 ef ff	jsr $ffef	    jsr ECHO
.f1c3	20 6c f0	jsr $f06c	    jsr calc_prg_stop
.f1c6	a5 23		lda $23		    lda prg_stop+1      ; stop high
.f1c8	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f1cb	a5 22		lda $22		    lda prg_stop        ; stop low
.f1cd	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f1d0	a9 20		lda #$20	    lda #' '
.f1d2	20 ef ff	jsr $ffef	    jsr ECHO
.f1d5	a5 04		lda $04		    lda buff_fe_size    ; size low
.f1d7	85 44		sta $44		    sta uint2str_number
.f1d9	a5 05		lda $05		    lda buff_fe_size+1  ; size high
.f1db	85 45		sta $45		    sta uint2str_number+1
.f1dd	20 1f fb	jsr $fb1f	    jsr uint2str
.f1e0	a2 00		ldx #$00	    ldx #0
.f1e2	20 10 f2	jsr $f210	    jsr list_print_uint2str_buffer
.f1e5	a9 20		lda #$20	    lda #' '
.f1e7	20 ef ff	jsr $ffef	    jsr ECHO
.f1ea	a5 00		lda $00		    lda buffer          ; block low
.f1ec	85 44		sta $44		    sta uint2str_number
.f1ee	a5 01		lda $01		    lda buffer+1        ; block high
.f1f0	85 45		sta $45		    sta uint2str_number+1
.f1f2	20 1f fb	jsr $fb1f	    jsr uint2str
.f1f5	a2 02		ldx #$02	    ldx #2              ; skip first two spaces
.f1f7	20 10 f2	jsr $f210	    jsr list_print_uint2str_buffer
.f1fa	a9 20		lda #$20	    lda #' '
.f1fc	20 ef ff	jsr $ffef	    jsr ECHO
.f1ff	a9 06		lda #$06	    lda #<buffer+6
.f201	85 2d		sta $2d		    sta ptr
.f203	a9 00		lda #$00	    lda #>buffer+6
.f205	85 2e		sta $2e		    sta ptr+1
.f207	20 31 f0	jsr $f031	    jsr print_msg
.f20a					list_print_fileentry_done:
.f20a	a9 0d		lda #$0d	    lda #CR
.f20c	20 ef ff	jsr $ffef	    jsr ECHO
.f20f	60		rts		    rts
.f210					list_print_uint2str_buffer:
.f210	b5 3e		lda $3e,x	    lda uint2str_buffer, x
.f212	20 ef ff	jsr $ffef	    jsr ECHO
.f215	e8		inx		    inx
.f216	e0 05		cpx #$05	    cpx #5
.f218	d0 f6		bne $f210	    bne list_print_uint2str_buffer
.f21a	60		rts		    rts

;******  Return to file: fdsh/fdsh.asm


;******  Processing file: fdsh/read.asm

.f21b					load:
.f21b	a9 62		lda #$62	    lda #'b'                    ; Integer-BASIC in ProDOS format
.f21d	85 2f		sta $2f		    sta flag
.f21f	4c 26 f2	jmp $f226	    jmp read_request
.f222					read:
.f222	a9 00		lda #$00	    lda #0                      ; regular file
.f224	85 2f		sta $2f		    sta flag
.f226					read_request:
.f226	a9 02		lda #$02	    lda #CMD_READ
.f228	20 02 f1	jsr $f102	    jsr send_request
.f22b	90 08		bcc $f235	    bcc read_request_ok         ; ok, continue
.f22d	c9 02		cmp #$02	    cmp #ST_DONE
.f22f	f0 69		beq $f29a	    beq read_done
.f231	c9 04		cmp #$04	    cmp #ST_ERROR
.f233	f0 6c		beq $f2a1	    beq read_err
.f235					read_request_ok:
.f235	c9 80		cmp #$80	    cmp #BODT
.f237	d0 61		bne $f29a	    bne read_done               ; nope, no data
.f239					read_fileentry:
.f239	a2 00		ldx #$00	    ldx #0
.f23b					read_fileentry_byte:
.f23b	20 90 f0	jsr $f090	    jsr receive_data_byte
.f23e	90 08		bcc $f248	    bcc read_fileentry_store    ; ok, continue
.f240	c9 02		cmp #$02	    cmp #ST_DONE
.f242	f0 56		beq $f29a	    beq read_done
.f244	c9 04		cmp #$04	    cmp #ST_ERROR
.f246	f0 59		beq $f2a1	    beq read_err
.f248					read_fileentry_store:
.f248	95 00		sta $00,x	    sta buffer, x
.f24a	e8		inx		    inx
.f24b	e0 20		cpx #$20	    cpx #32
.f24d	d0 ec		bne $f23b	    bne read_fileentry_byte     ; not done with FileEntry?
.f24f	a5 2f		lda $2f		    lda flag
.f251	f0 05		beq $f258	    beq read_receive_data_bytes ; process as regular file
.f253	20 ff f2	jsr $f2ff	    jsr load_basic_header
.f256	b0 50		bcs $f2a8	    bcs load_err                ; haven't succeeded
.f258					read_receive_data_bytes:
.f258	20 6c f0	jsr $f06c	    jsr calc_prg_stop
.f25b	20 b5 f2	jsr $f2b5	    jsr read_print_messages_start_stop
.f25e	a5 02		lda $02		    lda buff_fe_start
.f260	85 20		sta $20		    sta prg_start
.f262	85 2d		sta $2d		    sta ptr
.f264	a5 03		lda $03		    lda buff_fe_start+1
.f266	85 21		sta $21		    sta prg_start+1
.f268	85 2e		sta $2e		    sta ptr+1
.f26a					read_receive_data_byte:
.f26a	20 90 f0	jsr $f090	    jsr receive_data_byte
.f26d	90 08		bcc $f277	    bcc read_prg_store          ; ok, continue
.f26f	c9 02		cmp #$02	    cmp #ST_DONE
.f271	f0 1c		beq $f28f	    beq read_prg_done
.f273	c9 04		cmp #$04	    cmp #ST_ERROR
.f275	f0 2a		beq $f2a1	    beq read_err
.f277					read_prg_store:
.f277	a0 00		ldy #$00	    ldy #$00
.f279	91 2d		sta ($2d),y	    sta (ptr),y
.f27b	e6 2d		inc $2d		    inc ptr
.f27d	d0 02		bne $f281	    bne read_skip_high          ; if ptr low byte did not wrap, skip high byte increment
.f27f	e6 2e		inc $2e		    inc ptr+1
.f281					read_skip_high:
.f281	a5 2e		lda $2e		    lda ptr+1
.f283	c5 23		cmp $23		    cmp prg_stop+1              ; compare high byte first
.f285	90 e3		bcc $f26a	    bcc read_receive_data_byte  ; if ptr+1 < prg_stop+1, continue
.f287	d0 06		bne $f28f	    bne read_prg_done           ; if ptr+1 > prg_stop+1, exit
.f289	a5 2d		lda $2d		    lda ptr
.f28b	c5 22		cmp $22		    cmp prg_stop
.f28d	90 db		bcc $f26a	    bcc read_receive_data_byte  ; if ptr < prg_stop, continue
.f28f					read_prg_done:
.f28f	a9 62		lda #$62	    lda #<read_msg3
.f291	85 2d		sta $2d		    sta ptr
.f293	a9 f3		lda #$f3	    lda #>read_msg3
.f295	85 2e		sta $2e		    sta ptr+1
.f297	20 31 f0	jsr $f031	    jsr print_msg
.f29a					read_done:
.f29a	a9 0d		lda #$0d	    lda #CR
.f29c	20 ef ff	jsr $ffef	    jsr ECHO
.f29f	18		clc		    clc                         ; success
.f2a0	60		rts		    rts
.f2a1					read_err:
.f2a1	a9 21		lda #$21	    lda #'!'
.f2a3	20 ef ff	jsr $ffef	    jsr ECHO
.f2a6	38		sec		    sec                         ; failure
.f2a7	60		rts		    rts
.f2a8					load_err:
.f2a8	a9 6c		lda #$6c	    lda #<load_msg1
.f2aa	85 2d		sta $2d		    sta ptr
.f2ac	a9 f3		lda #$f3	    lda #>load_msg1
.f2ae	85 2e		sta $2e		    sta ptr+1
.f2b0	20 31 f0	jsr $f031	    jsr print_msg
.f2b3	38		sec		    sec                         ; failure
.f2b4	60		rts		    rts
.f2b5					read_print_messages_start_stop:
.f2b5	a9 4b		lda #$4b	    lda #<read_msg1
.f2b7	85 2d		sta $2d		    sta ptr
.f2b9	a9 f3		lda #$f3	    lda #>read_msg1
.f2bb	85 2e		sta $2e		    sta ptr+1
.f2bd	20 31 f0	jsr $f031	    jsr print_msg
.f2c0	a9 06		lda #$06	    lda #<buffer+6
.f2c2	85 2d		sta $2d		    sta ptr
.f2c4	a9 00		lda #$00	    lda #>buffer+6
.f2c6	85 2e		sta $2e		    sta ptr+1
.f2c8	20 31 f0	jsr $f031	    jsr print_msg
.f2cb	a9 54		lda #$54	    lda #<read_msg2
.f2cd	85 2d		sta $2d		    sta ptr
.f2cf	a9 f3		lda #$f3	    lda #>read_msg2
.f2d1	85 2e		sta $2e		    sta ptr+1
.f2d3	20 31 f0	jsr $f031	    jsr print_msg
.f2d6	a5 03		lda $03		    lda buff_fe_start+1         ; start high
.f2d8	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f2db	a5 02		lda $02		    lda buff_fe_start           ; start low
.f2dd	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f2e0	a9 20		lda #$20	    lda #' '
.f2e2	20 ef ff	jsr $ffef	    jsr ECHO
.f2e5	a9 2d		lda #$2d	    lda #'-'
.f2e7	20 ef ff	jsr $ffef	    jsr ECHO
.f2ea	a9 20		lda #$20	    lda #' '
.f2ec	20 ef ff	jsr $ffef	    jsr ECHO
.f2ef	a5 23		lda $23		    lda prg_stop+1              ; stop high
.f2f1	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f2f4	a5 22		lda $22		    lda prg_stop                ; stop low
.f2f6	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f2f9	a9 20		lda #$20	    lda #' '
.f2fb	20 ef ff	jsr $ffef	    jsr ECHO
.f2fe	60		rts		    rts
.f2ff					load_basic_header:
.f2ff	20 90 f0	jsr $f090	    jsr receive_data_byte
.f302	b0 45		bcs $f349	    bcs load_basic_err          ; byte is expected
.f304	c9 41		cmp #$41	    cmp #'A'
.f306	d0 41		bne $f349	    bne load_basic_err          ; file signature is expected
.f308	20 90 f0	jsr $f090	    jsr receive_data_byte
.f30b	b0 3c		bcs $f349	    bcs load_basic_err          ; byte is expected
.f30d	c9 31		cmp #$31	    cmp #'1'
.f30f	d0 38		bne $f349	    bne load_basic_err          ; file signature is expected
.f311	a9 02		lda #$02	    lda #2
.f313	85 2d		sta $2d		    sta ptr                     ; we've already received 2 bytes
.f315					load_skip_zp_loop:
.f315	20 90 f0	jsr $f090	    jsr receive_data_byte
.f318	b0 2f		bcs $f349	    bcs load_basic_err          ; byte is expected
.f31a	e6 2d		inc $2d		    inc ptr
.f31c	a5 2d		lda $2d		    lda ptr
.f31e	c9 4a		cmp #$4a	    cmp #$4a
.f320	d0 f3		bne $f315	    bne load_skip_zp_loop
.f322	a9 00		lda #$00	    lda #0                      ; ZP
.f324	85 2e		sta $2e		    sta ptr+1                   ; while LSB points to $4a
.f326					read_receive_zp_data_byte:
.f326	20 90 f0	jsr $f090	    jsr receive_data_byte
.f329	b0 1e		bcs $f349	    bcs load_basic_err          ; byte is expected
.f32b	a0 00		ldy #$00	    ldy #$00
.f32d	91 2d		sta ($2d),y	    sta (ptr),y
.f32f	e6 2d		inc $2d		    inc ptr
.f331	d0 f3		bne $f326	    bne read_receive_zp_data_byte   ; loop until value wrapps
.f333	a9 01		lda #$01	    lda #1                      ; stack, first page
.f335	85 2e		sta $2e		    sta ptr+1                   ; ZP, while LSB is 0
.f337					load_skip_stack_loop:
.f337	20 90 f0	jsr $f090	    jsr receive_data_byte
.f33a	b0 0d		bcs $f349	    bcs load_basic_err          ; byte is expected
.f33c	e6 2d		inc $2d		    inc ptr
.f33e	d0 f7		bne $f337	    bne load_skip_stack_loop
.f340	a5 05		lda $05		    lda buff_fe_size+1
.f342	38		sec		    sec
.f343	e9 02		sbc #$02	    sbc #$02
.f345	85 05		sta $05		    sta buff_fe_size+1
.f347	18		clc		    clc                         ; success
.f348	60		rts		    rts
.f349					load_basic_err:
.f349	38		sec		    sec                         ; failure
.f34a	60		rts		    rts
>f34b	52 65 61 64 69 6e 67 20		read_msg1:  .text "Reading ", 0
>f353	00
>f354	20 69 6e 74 6f 20 6d 65		read_msg2:  .text " into memory ", 0
>f35c	6d 6f 72 79 20 00
>f362	20 2e 2e 20 64 6f 6e 65		read_msg3:  .text " .. done.", 0
>f36a	2e 00
>f36c	54 68 69 73 20 69 73 20		load_msg1:  .text "This is not BASIC program", 13, 0
>f374	6e 6f 74 20 42 41 53 49 43 20 70 72 6f 67 72 61
>f384	6d 0d 00

;******  Return to file: fdsh/fdsh.asm


;******  Processing file: fdsh/write.asm

.f387					save:
.f387	a5 4a		lda $4a		    lda lomem
.f389	85 20		sta $20		    sta prg_start
.f38b	a5 4b		lda $4b		    lda lomem+1
.f38d	85 21		sta $21		    sta prg_start+1
.f38f	a5 4c		lda $4c		    lda himem
.f391	85 22		sta $22		    sta prg_stop
.f393	a5 4d		lda $4d		    lda himem+1
.f395	85 23		sta $23		    sta prg_stop+1
.f397	38		sec		    sec                     ; clear borrow
.f398	a5 22		lda $22		    lda prg_stop
.f39a	e5 20		sbc $20		    sbc prg_start
.f39c	85 3e		sta $3e		    sta tmp_buffer
.f39e	a5 23		lda $23		    lda prg_stop+1
.f3a0	e5 21		sbc $21		    sbc prg_start+1         ; Subtract with borrow
.f3a2	18		clc		    clc
.f3a3	69 02		adc #$02	    adc #$02
.f3a5	85 3f		sta $3f		    sta tmp_buffer+1
.f3a7	a2 03		ldx #$03	    ldx #3                  ; Start searchging for end-of-string from name position
.f3a9					save_eos_loop:
.f3a9	b5 00		lda $00,x	    lda buffer, x
.f3ab	f0 04		beq $f3b1	    beq save_eos_found
.f3ad	e8		inx		    inx
.f3ae	4c a9 f3	jmp $f3a9	    jmp save_eos_loop
.f3b1					save_eos_found:
.f3b1	a9 23		lda #$23	    lda #'#'
.f3b3	95 00		sta $00,x	    sta buffer, x
.f3b5	e8		inx		    inx
.f3b6	a5 21		lda $21		    lda prg_start+1
.f3b8	20 13 f5	jsr $f513	    jsr write_byte_hex_to_buffer
.f3bb	a5 20		lda $20		    lda prg_start
.f3bd	20 13 f5	jsr $f513	    jsr write_byte_hex_to_buffer
.f3c0	a9 23		lda #$23	    lda #'#'
.f3c2	95 00		sta $00,x	    sta buffer, x
.f3c4	e8		inx		    inx
.f3c5	a5 3f		lda $3f		    lda tmp_buffer+1
.f3c7	20 13 f5	jsr $f513	    jsr write_byte_hex_to_buffer
.f3ca	a5 3e		lda $3e		    lda tmp_buffer
.f3cc	20 13 f5	jsr $f513	    jsr write_byte_hex_to_buffer
.f3cf	a9 00		lda #$00	    lda #0
.f3d1	95 00		sta $00,x	    sta buffer, x
.f3d3	a9 03		lda #$03	    lda #CMD_WRITE
.f3d5	20 02 f1	jsr $f102	    jsr send_request
.f3d8	90 08		bcc $f3e2	    bcc store_header        ; ok, continue
.f3da	c9 02		cmp #$02	    cmp #ST_DONE
.f3dc	f0 46		beq $f424	    beq store_done
.f3de	c9 04		cmp #$04	    cmp #ST_ERROR
.f3e0	f0 45		beq $f427	    beq store_err
.f3e2					store_header:
.f3e2	a9 41		lda #$41	    lda #'A'
.f3e4	85 00		sta $00		    sta $00
.f3e6	a9 31		lda #$31	    lda #'1'
.f3e8	85 01		sta $01		    sta $01
.f3ea	a9 80		lda #$80	    lda #BODT
.f3ec	20 c4 f0	jsr $f0c4	    jsr send_byte
.f3ef	b0 36		bcs $f427	    bcs store_err           ; timeout
.f3f1	20 7a f0	jsr $f07a	    jsr receive_byte        ; ACK is expected
.f3f4	b0 31		bcs $f427	    bcs store_err           ; timeout
.f3f6	c9 af		cmp #$af	    cmp #NACK
.f3f8	f0 2a		beq $f424	    beq store_done
.f3fa	a9 00		lda #$00	    lda #0
.f3fc	85 2d		sta $2d		    sta ptr
.f3fe	85 2e		sta $2e		    sta ptr+1
.f400					store_header_loop:
.f400	a5 2e		lda $2e		    lda ptr+1
.f402	c9 02		cmp #$02	    cmp #$02
.f404	d0 06		bne $f40c	    bne store_header_store
.f406	a5 2d		lda $2d		    lda ptr
.f408	c9 00		cmp #$00	    cmp #$00
.f40a	f0 12		beq $f41e	    beq store_header_done
.f40c					store_header_store:
.f40c	a0 00		ldy #$00	    ldy #$00
.f40e	b1 2d		lda ($2d),y	    lda (ptr),y
.f410	20 e2 f0	jsr $f0e2	    jsr send_data_byte
.f413	b0 12		bcs $f427	    bcs store_err           ; timeout
.f415	e6 2d		inc $2d		    inc ptr
.f417	d0 e7		bne $f400	    bne store_header_loop
.f419	e6 2e		inc $2e		    inc ptr+1
.f41b	4c 00 f4	jmp $f400	    jmp store_header_loop
.f41e					store_header_done:
.f41e	20 31 f5	jsr $f531	    jsr write_print_messages
.f421	4c 51 f4	jmp $f451	    jmp write_prg_loop_init
.f424					store_done:
.f424	4c 8e f4	jmp $f48e	    jmp write_done
.f427					store_err:
.f427	4c 94 f4	jmp $f494	    jmp write_err
.f42a					write:
.f42a	20 9a f4	jsr $f49a	    jsr write_parse_cmd_args
.f42d	b0 65		bcs $f494	    bcs write_err           ; invalid command line
.f42f	20 31 f5	jsr $f531	    jsr write_print_messages
.f432	a9 03		lda #$03	    lda #CMD_WRITE
.f434	20 02 f1	jsr $f102	    jsr send_request
.f437	90 08		bcc $f441	    bcc write_data_start    ; ok, continue
.f439	c9 02		cmp #$02	    cmp #ST_DONE
.f43b	f0 51		beq $f48e	    beq write_done
.f43d	c9 04		cmp #$04	    cmp #ST_ERROR
.f43f	f0 53		beq $f494	    beq write_err
.f441					write_data_start:
.f441	a9 80		lda #$80	    lda #BODT
.f443	20 c4 f0	jsr $f0c4	    jsr send_byte
.f446	b0 4c		bcs $f494	    bcs write_err           ; timeout
.f448	20 7a f0	jsr $f07a	    jsr receive_byte        ; ACK is expected
.f44b	b0 47		bcs $f494	    bcs write_err           ; timeout
.f44d	c9 af		cmp #$af	    cmp #NACK
.f44f	f0 3d		beq $f48e	    beq write_done
.f451					write_prg_loop_init:
.f451	a5 20		lda $20		    lda prg_start
.f453	85 2d		sta $2d		    sta ptr
.f455	a5 21		lda $21		    lda prg_start+1
.f457	85 2e		sta $2e		    sta ptr+1
.f459					write_prg_loop:
.f459	a5 2e		lda $2e		    lda ptr+1
.f45b	c5 23		cmp $23		    cmp prg_stop+1
.f45d	d0 06		bne $f465	    bne write_prg_store
.f45f	a5 2d		lda $2d		    lda ptr
.f461	c5 22		cmp $22		    cmp prg_stop
.f463	f0 12		beq $f477	    beq write_prg_stop
.f465					write_prg_store:
.f465	a0 00		ldy #$00	    ldy #$00
.f467	b1 2d		lda ($2d),y	    lda (ptr),y
.f469	20 e2 f0	jsr $f0e2	    jsr send_data_byte
.f46c	b0 26		bcs $f494	    bcs write_err           ; timeout
.f46e	e6 2d		inc $2d		    inc ptr
.f470	d0 e7		bne $f459	    bne write_prg_loop
.f472	e6 2e		inc $2e		    inc ptr+1
.f474	4c 59 f4	jmp $f459	    jmp write_prg_loop
.f477					write_prg_stop:
.f477	a9 8f		lda #$8f	    lda #EODT
.f479	20 c4 f0	jsr $f0c4	    jsr send_byte
.f47c	b0 16		bcs $f494	    bcs write_err           ; timeout
.f47e	20 7a f0	jsr $f07a	    jsr receive_byte        ; ACK is expected
.f481	b0 11		bcs $f494	    bcs write_err           ; timeout
.f483	a9 84		lda #$84	    lda #<write_msg3
.f485	85 2d		sta $2d		    sta ptr
.f487	a9 f5		lda #$f5	    lda #>write_msg3
.f489	85 2e		sta $2e		    sta ptr+1
.f48b	20 31 f0	jsr $f031	    jsr print_msg
.f48e					write_done:
.f48e	a9 0d		lda #$0d	    lda #CR
.f490	20 ef ff	jsr $ffef	    jsr ECHO
.f493	60		rts		    rts
.f494					write_err:
.f494	a9 21		lda #$21	    lda #'!'
.f496	20 ef ff	jsr $ffef	    jsr ECHO
.f499	60		rts		    rts
.f49a					write_parse_cmd_args:
.f49a	a2 03		ldx #$03	    ldx #$03                ; index in string
.f49c					find_first_hash:
.f49c	b5 00		lda $00,x	    lda buffer, x
.f49e	e8		inx		    inx
.f49f	f0 42		beq $f4e3	    beq write_parse_cmd_args_err ; no '#' within buffer
.f4a1	c9 23		cmp #$23	    cmp #$23                ; '#'
.f4a3	d0 f7		bne $f49c	    bne find_first_hash
.f4a5	c0 02		cpy #$02	    cpy #$02
.f4a7	f0 3a		beq $f4e3	    beq write_parse_cmd_args_err ; name is empy
.f4a9	20 e5 f4	jsr $f4e5	    jsr parse_addr          ; Parse 4-digit hex value into ptr
.f4ac	a5 2d		lda $2d		    lda ptr
.f4ae	85 20		sta $20		    sta prg_start
.f4b0	a5 2e		lda $2e		    lda ptr+1
.f4b2	85 21		sta $21		    sta prg_start+1
.f4b4	b5 00		lda $00,x	    lda buffer, x
.f4b6	c9 23		cmp #$23	    cmp #$23                ; second '#' is expected
.f4b8	d0 29		bne $f4e3	    bne write_parse_cmd_args_err
.f4ba	e8		inx		    inx                     ; point to next value
.f4bb	8a		txa		    txa                     ; save this position
.f4bc	48		pha		    pha
.f4bd	20 e5 f4	jsr $f4e5	    jsr parse_addr          ; Parse 4-digit hex value into ptr
.f4c0	a5 2d		lda $2d		    lda ptr
.f4c2	85 22		sta $22		    sta prg_stop
.f4c4	a5 2e		lda $2e		    lda ptr+1
.f4c6	85 23		sta $23		    sta prg_stop+1
.f4c8	38		sec		    sec                     ; clear borrow
.f4c9	a5 22		lda $22		    lda prg_stop
.f4cb	e5 20		sbc $20		    sbc prg_start
.f4cd	85 3e		sta $3e		    sta tmp_buffer
.f4cf	a5 23		lda $23		    lda prg_stop+1
.f4d1	e5 21		sbc $21		    sbc prg_start+1         ; Subtract with borrow
.f4d3	85 3f		sta $3f		    sta tmp_buffer+1
.f4d5	68		pla		    pla
.f4d6	aa		tax		    tax
.f4d7	a5 3f		lda $3f		    lda tmp_buffer+1
.f4d9	20 13 f5	jsr $f513	    jsr write_byte_hex_to_buffer
.f4dc	a5 3e		lda $3e		    lda tmp_buffer
.f4de	20 13 f5	jsr $f513	    jsr write_byte_hex_to_buffer
.f4e1	18		clc		    clc
.f4e2	60		rts		    rts
.f4e3					write_parse_cmd_args_err:
.f4e3	38		sec		    sec
.f4e4	60		rts		    rts
.f4e5					parse_addr:
.f4e5	a9 00		lda #$00	    lda #$00
.f4e7	85 2d		sta $2d		    sta ptr
.f4e9	85 2e		sta $2e		    sta ptr+1
.f4eb	a0 00		ldy #$00	    ldy #$00                ; Digit counter (4 per value)
.f4ed					parse_addr_loop:
.f4ed	b5 00		lda $00,x	    lda buffer, x
.f4ef	f0 21		beq $f512	    beq parse_addr_done     ; null terminator
.f4f1	c9 23		cmp #$23	    cmp #$23                ; next '#'
.f4f3	f0 1d		beq $f512	    beq parse_addr_done
.f4f5	20 51 f0	jsr $f051	    jsr hex_to_bin          ; ASCII hex to binary nibble
.f4f8	06 2d		asl $2d		    asl ptr
.f4fa	26 2e		rol $2e		    rol ptr+1
.f4fc	06 2d		asl $2d		    asl ptr
.f4fe	26 2e		rol $2e		    rol ptr+1
.f500	06 2d		asl $2d		    asl ptr
.f502	26 2e		rol $2e		    rol ptr+1
.f504	06 2d		asl $2d		    asl ptr
.f506	26 2e		rol $2e		    rol ptr+1
.f508	05 2d		ora $2d		    ora ptr                 ; Add nibble to lower byte
.f50a	85 2d		sta $2d		    sta ptr
.f50c	e8		inx		    inx
.f50d	c8		iny		    iny
.f50e	c0 04		cpy #$04	    cpy #$04                ; Process exactly 4 digits
.f510	d0 db		bne $f4ed	    bne parse_addr_loop
.f512					parse_addr_done:
.f512	60		rts		    rts
.f513					write_byte_hex_to_buffer:
.f513	48		pha		    pha              ; Save A
.f514	4a		lsr a		    lsr              ; Shift high nibble to low
.f515	4a		lsr a		    lsr
.f516	4a		lsr a		    lsr
.f517	4a		lsr a		    lsr
.f518	20 28 f5	jsr $f528	    jsr nibble_to_ascii
.f51b	95 00		sta $00,x	    sta buffer,x     ; Store in buffer
.f51d	e8		inx		    inx
.f51e	68		pla		    pla              ; Restore original value
.f51f	29 0f		and #$0f	    and #$0F         ; Mask out low nibble
.f521	20 28 f5	jsr $f528	    jsr nibble_to_ascii
.f524	95 00		sta $00,x	    sta buffer,x     ; Store in buffer
.f526	e8		inx		    inx
.f527	60		rts		    rts
.f528					nibble_to_ascii:
.f528	c9 0a		cmp #$0a	    cmp #10          ; If >= 10, it's A-F
.f52a	90 02		bcc $f52e	    bcc nibble_to_ascii_digit
.f52c	69 06		adc #$06	    adc #6           ; Adjust for ASCII 'A'-'F'
.f52e					nibble_to_ascii_digit:
.f52e	69 30		adc #$30	    adc #$30         ; Convert to ASCII ('0'-'9' or 'A'-'F')
.f530	60		rts		    rts
.f531					write_print_messages:
.f531	a9 6b		lda #$6b	    lda #<write_msg1
.f533	85 2d		sta $2d		    sta ptr
.f535	a9 f5		lda #$f5	    lda #>write_msg1
.f537	85 2e		sta $2e		    sta ptr+1
.f539	20 31 f0	jsr $f031	    jsr print_msg
.f53c	a5 21		lda $21		    lda prg_start+1         ; start high
.f53e	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f541	a5 20		lda $20		    lda prg_start           ; start low
.f543	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f546	a9 20		lda #$20	    lda #' '
.f548	20 ef ff	jsr $ffef	    jsr ECHO
.f54b	a9 2d		lda #$2d	    lda #'-'
.f54d	20 ef ff	jsr $ffef	    jsr ECHO
.f550	a9 20		lda #$20	    lda #' '
.f552	20 ef ff	jsr $ffef	    jsr ECHO
.f555	a5 23		lda $23		    lda prg_stop+1          ; stop high
.f557	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f55a	a5 22		lda $22		    lda prg_stop            ; stop low
.f55c	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f55f	a9 7b		lda #$7b	    lda #<write_msg2
.f561	85 2d		sta $2d		    sta ptr
.f563	a9 f5		lda #$f5	    lda #>write_msg2
.f565	85 2e		sta $2e		    sta ptr+1
.f567	20 31 f0	jsr $f031	    jsr print_msg
.f56a	60		rts		    rts
>f56b	57 72 69 74 69 6e 67 20		write_msg1:  .text "Writing memory ", 0
>f573	6d 65 6d 6f 72 79 20 00
>f57b	20 74 6f 20 66 69 6c 65		write_msg2:  .text " to file", 0
>f583	00
>f584	20 2e 2e 20 64 6f 6e 65		write_msg3:  .text " .. done.", 0
>f58c	2e 00

;******  Return to file: fdsh/fdsh.asm


;******  Processing file: fdsh/delete.asm

.f58e					delete:
.f58e	a9 bf		lda #$bf	    lda #<delete_msg
.f590	85 2d		sta $2d		    sta ptr
.f592	a9 f5		lda #$f5	    lda #>delete_msg
.f594	85 2e		sta $2e		    sta ptr+1
.f596	20 31 f0	jsr $f031	    jsr print_msg
.f599					delete_confirm:
.f599	20 be fa	jsr $fabe	    jsr KBDIN
.f59c	c9 1b		cmp #$1b	    cmp #ESC
.f59e	f0 13		beq $f5b3	    beq delete_done
.f5a0	c9 0d		cmp #$0d	    cmp #CR
.f5a2	d0 f5		bne $f599	    bne delete_confirm
.f5a4	a9 04		lda #$04	    lda #CMD_DELETE
.f5a6	20 02 f1	jsr $f102	    jsr send_request
.f5a9	90 08		bcc $f5b3	    bcc delete_done         ; ok, continue
.f5ab	c9 02		cmp #$02	    cmp #ST_DONE
.f5ad	f0 04		beq $f5b3	    beq delete_done
.f5af	c9 04		cmp #$04	    cmp #ST_ERROR
.f5b1	f0 06		beq $f5b9	    beq delete_err
.f5b3					delete_done:
.f5b3	a9 0d		lda #$0d	    lda #CR
.f5b5	20 ef ff	jsr $ffef	    jsr ECHO
.f5b8	60		rts		    rts
.f5b9					delete_err:
.f5b9	a9 21		lda #$21	    lda #'!'
.f5bb	20 ef ff	jsr $ffef	    jsr ECHO
.f5be	60		rts		    rts
>f5bf	50 72 65 73 73 20 43 52		delete_msg: .text "Press CR to delete or ESC to cancel", 0
>f5c7	20 74 6f 20 64 65 6c 65 74 65 20 6f 72 20 45 53
>f5d7	43 20 74 6f 20 63 61 6e 63 65 6c 00

;******  Return to file: fdsh/fdsh.asm

.f5e3					fdsh_init:
.f5e3	a9 10		lda #$10	    lda #DAT
.f5e5	85 3c		sta $3c		    sta dat_mask    ; A bit to test to distinguish between data and ctrl byte
.f5e7	a9 00		lda #$00	    lda #0
.f5e9	85 30		sta $30		    sta prefix      ; clear prefix buffer
.f5eb	a9 00		lda #$00	    lda #$00        ; Default to WozMon
.f5ed	85 20		sta $20		    sta prg_start
.f5ef	a9 ff		lda #$ff	    lda #$ff
.f5f1	85 21		sta $21		    sta prg_start+1
.f5f3	a9 0d		lda #$0d	    lda #CR
.f5f5	20 ef ff	jsr $ffef	    jsr ECHO
.f5f8					menu:
.f5f8	a9 24		lda #$24	    lda #'$'
.f5fa	20 ef ff	jsr $ffef	    jsr ECHO
.f5fd	a2 00		ldx #$00	    ldx #0
.f5ff					menu_input:
.f5ff	20 be fa	jsr $fabe	    jsr KBDIN
.f602	20 ef ff	jsr $ffef	    jsr ECHO
.f605	95 00		sta $00,x	    sta buffer, x
.f607	c9 08		cmp #$08	    cmp #BS
.f609	f0 0c		beq $f617	    beq menu_input_back
.f60b	c9 1b		cmp #$1b	    cmp #ESC
.f60d	f0 55		beq $f664	    beq exit
.f60f	c9 0d		cmp #$0d	    cmp #CR
.f611	f0 0c		beq $f61f	    beq menu_process
.f613	e8		inx		    inx
.f614	4c ff f5	jmp $f5ff	    jmp menu_input
.f617					menu_input_back:
.f617	e0 00		cpx #$00	    cpx #0
.f619	f0 e4		beq $f5ff	    beq menu_input
.f61b	ca		dex		    dex
.f61c	4c ff f5	jmp $f5ff	    jmp menu_input
.f61f					menu_process:
.f61f	a9 00		lda #$00	    lda #0          ; replaece CR with #0
.f621	95 00		sta $00,x	    sta buffer, x
.f623	95 01		sta $01,x	    sta buffer+1, x ; arg for e.g. 'LS' must be #0 or valid string
.f625	a5 02		lda $02		    lda buffer+2    ; SP or 0 is expected
.f627	f0 04		beq $f62d	    beq menu_process_cont
.f629	c9 20		cmp #$20	    cmp #' '
.f62b	d0 29		bne $f656	    bne unknown_cmd
.f62d					menu_process_cont:
.f62d	a5 00		lda $00		    lda buffer      ; 1st cmd byte
.f62f	a6 01		ldx $01		    ldx buffer+1    ; 2nd cmd byte
.f631	a0 00		ldy #$00	    ldy #0          ; index in cmd_table
.f633					search_command:
.f633	b9 c7 f6	lda $f6c7,y	    lda cmd_table,y
.f636	f0 1e		beq $f656	    beq unknown_cmd ; end of cmd_table
.f638	c5 00		cmp $00		    cmp buffer      ; cmp first character
.f63a	d0 14		bne $f650	    bne next_cmd
.f63c	b9 c8 f6	lda $f6c8,y	    lda cmd_table+1,y
.f63f	c5 01		cmp $01		    cmp buffer+1    ; cmp second character
.f641	d0 0d		bne $f650	    bne next_cmd
.f643	b9 c9 f6	lda $f6c9,y	    lda cmd_table+2, y
.f646	85 2d		sta $2d		    sta ptr
.f648	b9 ca f6	lda $f6ca,y	    lda cmd_table+3, y
.f64b	85 2e		sta $2e		    sta ptr+1
.f64d	6c 2d 00	jmp ($002d)	    jmp (ptr)
.f650					next_cmd:
.f650	c8		iny		    iny
.f651	c8		iny		    iny
.f652	c8		iny		    iny
.f653	c8		iny		    iny
.f654	d0 dd		bne $f633	    bne search_command
.f656					unknown_cmd:
.f656	a9 ec		lda #$ec	    lda #<help
.f658	85 2d		sta $2d		    sta ptr
.f65a	a9 f6		lda #$f6	    lda #>help
.f65c	85 2e		sta $2e		    sta ptr+1
.f65e	20 31 f0	jsr $f031	    jsr print_msg
.f661	4c f8 f5	jmp $f5f8	    jmp menu
.f664					exit:
.f664	4c 00 ff	jmp $ff00	    jmp $ff00           ; WozMon entry
.f667					do_list:
.f667	20 72 f1	jsr $f172	    jsr list
.f66a	4c f8 f5	jmp $f5f8	    jmp menu
.f66d					do_read:
.f66d	20 22 f2	jsr $f222	    jsr read
.f670	4c f8 f5	jmp $f5f8	    jmp menu
.f673					do_load:
.f673	20 1b f2	jsr $f21b	    jsr load
.f676	4c f8 f5	jmp $f5f8	    jmp menu
.f679					do_write:
.f679	20 2a f4	jsr $f42a	    jsr write
.f67c	4c f8 f5	jmp $f5f8	    jmp menu
.f67f					do_save:
.f67f	20 87 f3	jsr $f387	    jsr save
.f682	4c f8 f5	jmp $f5f8	    jmp menu
.f685					do_run:
.f685	a2 02		ldx #$02	    ldx #2
.f687	b5 00		lda $00,x	    lda buffer,x
.f689	f0 08		beq $f693	    beq do_jmp          ; no arg, just jmp
.f68b	20 22 f2	jsr $f222	    jsr read
.f68e	90 03		bcc $f693	    bcc do_jmp          ; read succeeded
.f690	4c f8 f5	jmp $f5f8	    jmp menu
.f693					do_jmp:
.f693	6c 20 00	jmp ($0020)	    jmp (prg_start)     ; address must be set by loading or saving file
.f696					do_basic:
.f696	4c b3 e2	jmp $e2b3	    jmp $e2b3           ; BASIC warm entry
.f699					do_remove:
.f699	20 8e f5	jsr $f58e	    jsr delete
.f69c	4c f8 f5	jmp $f5f8	    jmp menu
.f69f					cd_prefix:
.f69f	a2 02		ldx #$02	    ldx #2
.f6a1	a0 00		ldy #$00	    ldy #0
.f6a3	b5 00		lda $00,x	    lda buffer,x
.f6a5	f0 18		beq $f6bf	    beq prefix_null_terminate
.f6a7	e8		inx		    inx                 ; skip SP
.f6a8					cd_prefix_loop:
.f6a8	b5 00		lda $00,x	    lda buffer,x
.f6aa	f0 09		beq $f6b5	    beq prefix_append_slash
.f6ac	99 30 00	sta $0030,y	    sta prefix,y
.f6af	e8		inx		    inx
.f6b0	c8		iny		    iny
.f6b1	c0 0a		cpy #$0a	    cpy #10
.f6b3	d0 f3		bne $f6a8	    bne cd_prefix_loop
.f6b5					prefix_append_slash:
.f6b5	c0 00		cpy #$00	    cpy #0
.f6b7	f0 06		beq $f6bf	    beq prefix_null_terminate
.f6b9	a9 2f		lda #$2f	    lda #$2F            ; '/'
.f6bb	99 30 00	sta $0030,y	    sta prefix,y
.f6be	c8		iny		    iny
.f6bf					prefix_null_terminate:
.f6bf	a9 00		lda #$00	    lda #$00
.f6c1	99 30 00	sta $0030,y	    sta prefix,y
.f6c4	4c f8 f5	jmp $f5f8	    jmp menu
.f6c7					cmd_table:
>f6c7	43 44 9f f6			    .byte 'C', 'D', <cd_prefix, >cd_prefix
>f6cb	4c 53 67 f6			    .byte 'L', 'S', <do_list,   >do_list
>f6cf	57 52 79 f6			    .byte 'W', 'R', <do_write,  >do_write
>f6d3	52 44 6d f6			    .byte 'R', 'D', <do_read,   >do_read
>f6d7	52 4e 85 f6			    .byte 'R', 'N', <do_run,    >do_run
>f6db	53 56 7f f6			    .byte 'S', 'V', <do_save,   >do_save
>f6df	4c 44 73 f6			    .byte 'L', 'D', <do_load,   >do_load
>f6e3	42 53 96 f6			    .byte 'B', 'S', <do_basic,  >do_basic
>f6e7	52 4d 99 f6			    .byte 'R', 'M', <do_remove, >do_remove
>f6eb	00				    .byte 0          ; End of table marker
.f6ec					help:
>f6ec	46 6c 61 73 68 44 69 73		    .text "FlashDisk Shell v", VERSION, " by Arvid Juskaitis", 13
>f6f4	6b 20 53 68 65 6c 6c 20 76 31 2e 30 20 62 79 20
>f704	41 72 76 69 64 20 4a 75 73 6b 61 69 74 69 73 0d
>f714	43 44 20 5b 64 69 72 65		    .text "CD [directory]", 13
>f71c	63 74 6f 72 79 5d 0d
>f723	4c 53 20 5b 70 72 65 66		    .text "LS [prefix]", 13
>f72b	69 78 5d 0d
>f72f	57 52 20 3c 66 69 6c 65		    .text "WR <filename>#start#stop", 13
>f737	6e 61 6d 65 3e 23 73 74 61 72 74 23 73 74 6f 70
>f747	0d
>f748	52 44 20 3c 66 69 6c 65		    .text "RD <filename|#block>", 13
>f750	6e 61 6d 65 7c 23 62 6c 6f 63 6b 3e 0d
>f75d	52 4e 20 5b 66 69 6c 65		    .text "RN [filename|#block]", 13
>f765	6e 61 6d 65 7c 23 62 6c 6f 63 6b 5d 0d
>f772	53 56 20 3c 66 69 6c 65		    .text "SV <filename>", 13
>f77a	6e 61 6d 65 3e 0d
>f780	4c 44 20 3c 66 69 6c 65		    .text "LD <filename|#block>", 13
>f788	6e 61 6d 65 7c 23 62 6c 6f 63 6b 3e 0d
>f795	42 53 0d			    .text "BS", 13
>f798	52 4d 20 3c 66 69 6c 65		    .text "RM <filename|#block>", 13
>f7a0	6e 61 6d 65 7c 23 62 6c 6f 63 6b 3e 0d
>f7ad	00				    .text 0

;******  Return to file: apple1.asm


;******  Processing file: loader/loader.asm

=$c000					ACIA_CTRL       = $c000
=$c000					ACIA_STATUS     = $c000
=$c001					ACIA_DATA       = $c001
=$46					checksum = tmp_buffer+8
.f800					entry_loader:
.f800					loader:
.f800	a9 03		lda #$03	    lda #%00000011          ; $02 master reset
.f802	8d 00 c0	sta $c000	    sta ACIA_CTRL
.f805	a9 16		lda #$16	    lda #%00010110          ; $16 28800 baud 8-n-1
.f807	8d 00 c0	sta $c000	    sta ACIA_CTRL
.f80a	a9 00		lda #$00	    lda #$00
.f80c	85 20		sta $20		    sta prg_start
.f80e	a9 ff		lda #$ff	    lda #$ff
.f810	85 21		sta $21		    sta prg_start+1
.f812					main_loop:
.f812	a9 19		lda #$19	    lda #<msg_wait
.f814	a2 f9		ldx #$f9	    ldx #>msg_wait
.f816	20 98 fa	jsr $fa98	    jsr PRINT_STR
.f819					wait_for_cmd:
.f819	20 c9 fa	jsr $fac9	    jsr KBDIN_NOWAIT
.f81c	f0 07		beq $f825	    beq wait_for_trasfer
.f81e	c9 0d		cmp #$0d	    cmp #$0d                ; CR
.f820	d0 6e		bne $f890	    bne loader_exit
.f822	6c 20 00	jmp ($0020)	    jmp (prg_start)
.f825					wait_for_trasfer:
.f825	ad 00 c0	lda $c000	    lda ACIA_STATUS
.f828	29 01		and #$01	    and #%00000001          ; Bit 0 = RDRF (data received)
.f82a	f0 ed		beq $f819	    beq wait_for_cmd
.f82c	20 c2 f8	jsr $f8c2	    jsr rx_byte
.f82f	85 2f		sta $2f		    sta flag
.f831	20 ef ff	jsr $ffef	    jsr ECHO
.f834	20 c2 f8	jsr $f8c2	    jsr rx_byte
.f837	85 20		sta $20		    sta prg_start
.f839	85 2d		sta $2d		    sta ptr
.f83b	20 c2 f8	jsr $f8c2	    jsr rx_byte
.f83e	85 21		sta $21		    sta prg_start+1
.f840	85 2e		sta $2e		    sta ptr+1
.f842	a9 2e		lda #$2e	    lda #'.'
.f844	20 ef ff	jsr $ffef	    jsr ECHO
.f847	20 c2 f8	jsr $f8c2	    jsr rx_byte
.f84a	85 22		sta $22		    sta prg_stop
.f84c	20 c2 f8	jsr $f8c2	    jsr rx_byte
.f84f	85 23		sta $23		    sta prg_stop+1
.f851	a9 2e		lda #$2e	    lda #'.'
.f853	20 ef ff	jsr $ffef	    jsr ECHO
.f856	a5 2f		lda $2f		    lda flag
.f858	c9 72		cmp #$72	    cmp #'r'
.f85a	f0 3c		beq $f898	    beq rx_tx
.f85c	c9 74		cmp #$74	    cmp #'t'
.f85e	f0 38		beq $f898	    beq rx_tx
.f860	4c 12 f8	jmp $f812	    jmp main_loop
.f863					loader_done:
.f863	a9 36		lda #$36	    lda #<msg_done
.f865	a2 f9		ldx #$f9	    ldx #>msg_done
.f867	20 98 fa	jsr $fa98	    jsr PRINT_STR
.f86a	a5 21		lda $21		    lda prg_start+1
.f86c	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f86f	a5 20		lda $20		    lda prg_start
.f871	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f874	a9 2d		lda #$2d	    lda #'-'
.f876	20 ef ff	jsr $ffef	    jsr ECHO
.f879	a5 23		lda $23		    lda prg_stop+1
.f87b	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f87e	a5 22		lda $22		    lda prg_stop
.f880	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f883	a9 4d		lda #$4d	    lda #<msg_chksm
.f885	a2 f9		ldx #$f9	    ldx #>msg_chksm
.f887	20 98 fa	jsr $fa98	    jsr PRINT_STR
.f88a	20 da f8	jsr $f8da	    jsr do_checksum
.f88d	4c 12 f8	jmp $f812	    jmp main_loop
.f890					loader_exit:
.f890	a9 2e		lda #$2e	    lda #'.'
.f892	20 ef ff	jsr $ffef	    jsr ECHO
.f895	4c 00 ff	jmp $ff00	    jmp $ff00               ; WozMon
.f898					rx_tx:
.f898	a0 00		ldy #$00	    ldy #$00
.f89a	a5 2f		lda $2f		    lda flag
.f89c	c9 72		cmp #$72	    cmp #'r'
.f89e	f0 08		beq $f8a8	    beq rx_tx_receive
.f8a0	b1 2d		lda ($2d),y	    lda (ptr),y
.f8a2	20 cd f8	jsr $f8cd	    jsr tx_byte
.f8a5	4c ad f8	jmp $f8ad	    jmp rx_tx_next
.f8a8					rx_tx_receive:
.f8a8	20 c2 f8	jsr $f8c2	    jsr rx_byte
.f8ab	91 2d		sta ($2d),y	    sta (ptr),y
.f8ad					rx_tx_next:
.f8ad	e6 2d		inc $2d		    inc ptr
.f8af	d0 02		bne $f8b3	    bne rx_tx_skip_high
.f8b1	e6 2e		inc $2e		    inc ptr+1
.f8b3					rx_tx_skip_high:
.f8b3	a5 2e		lda $2e		    lda ptr+1
.f8b5	c5 23		cmp $23		    cmp prg_stop+1
.f8b7	d0 df		bne $f898	    bne rx_tx
.f8b9	a5 2d		lda $2d		    lda ptr
.f8bb	c5 22		cmp $22		    cmp prg_stop
.f8bd	d0 d9		bne $f898	    bne rx_tx
.f8bf	4c 63 f8	jmp $f863	    jmp loader_done
.f8c2					rx_byte:
.f8c2	ad 00 c0	lda $c000	    lda ACIA_STATUS
.f8c5	29 01		and #$01	    and #%00000001          ; Bit 0 = RDRF (data received)
.f8c7	f0 f9		beq $f8c2	    beq rx_byte
.f8c9	ad 01 c0	lda $c001	    lda ACIA_DATA           ; Get received char
.f8cc	60		rts		    rts
.f8cd					tx_byte:
.f8cd	48		pha		    pha
.f8ce					wait_tx_ready:
.f8ce	ad 00 c0	lda $c000	    lda ACIA_STATUS
.f8d1	29 02		and #$02	    and #%00000010          ; Bit 1 = TDRE (transmit ready)
.f8d3	f0 f9		beq $f8ce	    beq wait_tx_ready
.f8d5	68		pla		    pla
.f8d6	8d 01 c0	sta $c001	    sta ACIA_DATA           ; Send byte over serial
.f8d9	60		rts		    rts
.f8da					do_checksum:
.f8da	a5 20		lda $20		    lda prg_start
.f8dc	85 2d		sta $2d		    sta ptr
.f8de	a5 21		lda $21		    lda prg_start+1
.f8e0	85 2e		sta $2e		    sta ptr+1
.f8e2	a9 00		lda #$00	    lda #0
.f8e4	85 46		sta $46		    sta checksum
.f8e6	85 47		sta $47		    sta checksum+1
.f8e8					checksum_loop:
.f8e8	a0 00		ldy #$00	    ldy #$00
.f8ea	b1 2d		lda ($2d),y	    lda (ptr),y
.f8ec	18		clc		    clc
.f8ed	65 46		adc $46		    adc checksum
.f8ef	85 46		sta $46		    sta checksum
.f8f1	a5 47		lda $47		    lda checksum+1
.f8f3	69 00		adc #$00	    adc #$00
.f8f5	85 47		sta $47		    sta checksum+1
.f8f7	e6 2d		inc $2d		    inc ptr
.f8f9	d0 02		bne $f8fd	    bne checksum_skip_high
.f8fb	e6 2e		inc $2e		    inc ptr+1
.f8fd					checksum_skip_high:
.f8fd	a5 2e		lda $2e		    lda ptr+1
.f8ff	c5 23		cmp $23		    cmp prg_stop+1
.f901	d0 e5		bne $f8e8	    bne checksum_loop
.f903	a5 2d		lda $2d		    lda ptr
.f905	c5 22		cmp $22		    cmp prg_stop
.f907	d0 df		bne $f8e8	    bne checksum_loop
.f909	a5 47		lda $47		    lda checksum+1
.f90b	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f90e	a5 46		lda $46		    lda checksum
.f910	20 dc ff	jsr $ffdc	    jsr PRBYTE
.f913	a9 0d		lda #$0d	    lda #$0d        ; CR
.f915	20 ef ff	jsr $ffef	    jsr ECHO
.f918	60		rts		    rts
>f919	0d 57 61 69 74 69 6e 67		msg_wait:   .text   13, "Waiting for transfer. Cmd? ", 0
>f921	20 66 6f 72 20 74 72 61 6e 73 66 65 72 2e 20 43
>f931	6d 64 3f 20 00
>f936	20 64 6f 6e 65 2e 0d 41		msg_done:   .text   " done.", 13, "Address range: ", 0
>f93e	64 64 72 65 73 73 20 72 61 6e 67 65 3a 20 00
>f94d	2c 20 63 68 65 63 6b 73		msg_chksm:  .text   ", checksum: ", 0
>f955	75 6d 3a 20 00

;******  Return to file: apple1.asm


;******  Processing file: extlib/extlib.asm

.fa00					entry_clear_screen:
.fa00	4c 2a fa	jmp $fa2a	    jmp clear_screen
.fa03					entry_set_cursor_pos:
.fa03	4c 38 fa	jmp $fa38	    jmp set_cursor_pos
.fa06					entry_set_color:
.fa06	4c 62 fa	jmp $fa62	    jmp set_color
.fa09					entry_print_str:
.fa09	4c 98 fa	jmp $fa98	    jmp print_str
.fa0c					entry_print_int:
.fa0c	4c af fa	jmp $faaf	    jmp print_int
.fa0f					entry_get_char:
.fa0f	4c be fa	jmp $fabe	    jmp KBDIN
.fa12					entry_get_char_nowait:
.fa12	4c c9 fa	jmp $fac9	    jmp KBDIN_NOWAIT
.fa15					entry_get_str:
.fa15	4c d7 fa	jmp $fad7	    jmp get_str
.fa18					entry_get_int:
.fa18	4c 0e fb	jmp $fb0e	    jmp get_int
.fa1b					entry_uint2str:
.fa1b	85 44		sta $44		    sta uint2str_number
.fa1d	86 45		stx $45		    stx uint2str_number+1
.fa1f	4c 1f fb	jmp $fb1f	    jmp uint2str
.fa22					entry_str2uint:
.fa22	20 63 fb	jsr $fb63	    jsr str2uint
.fa25	a5 44		lda $44		    lda str2uint_result
.fa27	a6 45		ldx $45		    ldx str2uint_result+1
.fa29	60		rts		    rts

;******  Processing file: extlib/ansiterm.asm

=$46					temp1 = tmp_buffer+8
=$47					temp2 = tmp_buffer+9
.fa2a					clear_screen:
.fa2a	20 75 fa	jsr $fa75	    jsr print_ansi_seq
.fa2d	a9 32		lda #$32	    lda #'2'
.fa2f	20 ef ff	jsr $ffef	    jsr ECHO
.fa32	a9 4a		lda #$4a	    lda #'J'
.fa34	20 ef ff	jsr $ffef	    jsr ECHO
.fa37	60		rts		    rts
.fa38					set_cursor_pos:
.fa38	85 46		sta $46		    sta temp1
.fa3a	86 47		stx $47		    stx temp2
.fa3c	a9 00		lda #$00	    lda #0          ; MSB is always 0
.fa3e	85 45		sta $45		    sta uint2str_number+1
.fa40	20 75 fa	jsr $fa75	    jsr print_ansi_seq
.fa43	a5 46		lda $46		    lda temp1       ; contains row positon
.fa45	85 44		sta $44		    sta uint2str_number
.fa47	20 1f fb	jsr $fb1f	    jsr uint2str
.fa4a	20 80 fa	jsr $fa80	    jsr print_uint2str_buffer
.fa4d	a9 3b		lda #$3b	    lda #';'
.fa4f	20 ef ff	jsr $ffef	    jsr ECHO
.fa52	a5 47		lda $47		    lda temp2       ; contains column positon
.fa54	85 44		sta $44		    sta uint2str_number
.fa56	20 1f fb	jsr $fb1f	    jsr uint2str
.fa59	20 80 fa	jsr $fa80	    jsr print_uint2str_buffer
.fa5c	a9 48		lda #$48	    lda #'H'
.fa5e	20 ef ff	jsr $ffef	    jsr ECHO
.fa61	60		rts		    rts
.fa62					set_color:
.fa62	48		pha		    pha
.fa63	20 75 fa	jsr $fa75	    jsr print_ansi_seq
.fa66	68		pla		    pla             ; contains 30-106 color value
.fa67	85 44		sta $44		    sta uint2str_number
.fa69	20 1f fb	jsr $fb1f	    jsr uint2str
.fa6c	20 80 fa	jsr $fa80	    jsr print_uint2str_buffer
.fa6f	a9 6d		lda #$6d	    lda #'m'
.fa71	20 ef ff	jsr $ffef	    jsr ECHO
.fa74	60		rts		    rts
.fa75					print_ansi_seq:
.fa75	a9 1b		lda #$1b	    lda #$1b        ; ESC
.fa77	20 ef ff	jsr $ffef	    jsr ECHO
.fa7a	a9 5b		lda #$5b	    lda #'['
.fa7c	20 ef ff	jsr $ffef	    jsr ECHO
.fa7f	60		rts		    rts
.fa80					print_uint2str_buffer:
.fa80	a2 02		ldx #$02	    ldx #2
.fa82					print_uint2str_buffer_skip_sp:
.fa82	b5 3e		lda $3e,x	    lda uint2str_buffer, x
.fa84	c9 20		cmp #$20	    cmp #' '
.fa86	d0 04		bne $fa8c	    bne print_uint2str_buffer_loop
.fa88	e8		inx		    inx
.fa89	4c 82 fa	jmp $fa82	    jmp print_uint2str_buffer_skip_sp
.fa8c					print_uint2str_buffer_loop:
.fa8c	b5 3e		lda $3e,x	    lda uint2str_buffer, x
.fa8e	f0 07		beq $fa97	    beq print_uint2str_buffer_done
.fa90	20 ef ff	jsr $ffef	    jsr ECHO
.fa93	e8		inx		    inx
.fa94	4c 8c fa	jmp $fa8c	    jmp print_uint2str_buffer_loop
.fa97					print_uint2str_buffer_done:
.fa97	60		rts		    rts

;******  Return to file: extlib/extlib.asm


;******  Processing file: extlib/conio.asm

=$46					print_str_ptr=tmp_buffer+8
.fa98					print_str:
.fa98	85 46		sta $46		    sta print_str_ptr
.fa9a	86 47		stx $47		    stx print_str_ptr+1
.fa9c					print_str_loop:
.fa9c	a0 00		ldy #$00	    ldy #0
.fa9e	b1 46		lda ($46),y	    lda (print_str_ptr), y
.faa0	f0 0c		beq $faae	    beq print_str_done
.faa2	20 ef ff	jsr $ffef	    jsr ECHO
.faa5	e6 46		inc $46		    inc print_str_ptr
.faa7	d0 f3		bne $fa9c	    bne print_str_loop
.faa9	e6 47		inc $47		    inc print_str_ptr+1
.faab	4c 9c fa	jmp $fa9c	    jmp print_str_loop
.faae					print_str_done:
.faae	60		rts		    rts
.faaf					print_int:
.faaf	85 44		sta $44			sta uint2str_number
.fab1	86 45		stx $45			stx uint2str_number+1
.fab3	20 1f fb	jsr $fb1f		jsr uint2str
.fab6	a9 3e		lda #$3e		lda #<uint2str_buffer
.fab8	a2 00		ldx #$00		ldx #>uint2str_buffer
.faba	20 98 fa	jsr $fa98		jsr print_str
.fabd	60		rts			rts
.fabe					KBDIN:
.fabe	ad 11 d0	lda $d011	    lda $D011       ; Read KBDCR (bit 7 set if key available)
.fac1	10 fb		bpl $fabe	    bpl KBDIN       ; Loop until a key is available
.fac3	ad 10 d0	lda $d010	    lda $D010       ; Read key
.fac6	29 7f		and #$7f	    and #$7F        ; Clear high bit
.fac8	60		rts		    rts             ; Return with character in A
.fac9					KBDIN_NOWAIT:
.fac9	ad 11 d0	lda $d011	    lda $D011       ; Read KBDCR
.facc	10 06		bpl $fad4	    bpl KBDIN_NOWAIT_none  ; If no key available, return 0
.face	ad 10 d0	lda $d010	    lda $D010       ; Read key
.fad1	29 7f		and #$7f	    and #$7F        ; Clear high bit
.fad3	60		rts		    rts
.fad4					KBDIN_NOWAIT_none:
.fad4	a9 00		lda #$00	    lda #0          ; Return 0 if no key
.fad6	60		rts		    rts
=$46					get_str_ptr=tmp_buffer+8
=$48					get_str_tmp=tmp_buffer+10
.fad7					get_str:
.fad7	85 46		sta $46		    sta get_str_ptr
.fad9	86 47		stx $47		    stx get_str_ptr+1
.fadb	84 48		sty $48		    sty get_str_tmp
.fadd	a0 00		ldy #$00	    ldy #0
.fadf					get_str_input:
.fadf	20 be fa	jsr $fabe	    jsr KBDIN
.fae2	91 46		sta ($46),y	    sta (get_str_ptr), y   ; Store character at target address
.fae4	c9 08		cmp #$08	    cmp #$8                 ; BS
.fae6	f0 13		beq $fafb	    beq get_str_input_back
.fae8	c9 1b		cmp #$1b	    cmp #$1b                ; ESC
.faea	f0 1a		beq $fb06	    beq get_str_exit
.faec	c9 0d		cmp #$0d	    cmp #$0d                ; CR
.faee	f0 18		beq $fb08	    beq get_str_done
.faf0	20 ef ff	jsr $ffef	    jsr ECHO
.faf3	c4 48		cpy $48		    cpy get_str_tmp
.faf5	f0 11		beq $fb08	    beq get_str_done
.faf7	c8		iny		    iny
.faf8	4c df fa	jmp $fadf	    jmp get_str_input
.fafb					get_str_input_back:
.fafb	20 ef ff	jsr $ffef	    jsr ECHO
.fafe	c0 00		cpy #$00	    cpy #0                  ; If at beginning, do nothing
.fb00	f0 dd		beq $fadf	    beq get_str_input
.fb02	88		dey		    dey
.fb03	4c df fa	jmp $fadf	    jmp get_str_input
.fb06					get_str_exit:
.fb06	a0 00		ldy #$00	    ldy #0                  ; Reset index
.fb08					get_str_done:
.fb08	a9 00		lda #$00	    lda #0                  ; Replace CR with 0
.fb0a	91 46		sta ($46),y	    sta (get_str_ptr), y
.fb0c	98		tya		    tya                     ; Return current index
.fb0d	60		rts			rts
.fb0e					get_int:
.fb0e	a9 3e		lda #$3e		lda #<str2uint_buffer
.fb10	a2 00		ldx #$00		ldx #>str2uint_buffer
.fb12	a0 05		ldy #$05		ldy #5
.fb14	20 d7 fa	jsr $fad7		jsr get_str
.fb17	20 63 fb	jsr $fb63		jsr str2uint
.fb1a	a5 44		lda $44			lda str2uint_result
.fb1c	a6 45		ldx $45			ldx str2uint_result+1
.fb1e	60		rts			rts

;******  Return to file: extlib/extlib.asm


;******  Processing file: extlib/uint2str.asm

=$3e					uint2str_buffer     = tmp_buffer    ; 6 bytes
=$44					uint2str_number     = tmp_buffer+6  ; 2 bytes
=$46					uint2str_remainder  = tmp_buffer+8  ; 1 byte
.fb1f					uint2str:
.fb1f	d8		cld		    cld                     ; Ensure decimal mode is off
.fb20	a2 04		ldx #$04	    ldx #4                  ; Now the last index is 4
.fb22	a9 20		lda #$20	    lda #' '                ; Space character
.fb24					fill_buffer:
.fb24	95 3e		sta $3e,x	    sta uint2str_buffer, x
.fb26	ca		dex		    dex
.fb27	10 fb		bpl $fb24	    bpl fill_buffer
.fb29	a9 00		lda #$00	    lda #0                  ; null terminate string
.fb2b	85 43		sta $43		    sta uint2str_buffer+5
.fb2d	a2 04		ldx #$04	    ldx #4                  ; Start storing digits from the rightmost position
.fb2f					uint2str_loop:
.fb2f	a5 44		lda $44		    lda uint2str_number
.fb31	05 45		ora $45		    ora uint2str_number+1
.fb33	f0 24		beq $fb59	    beq adjust_output       ; If number is zero, stop converting
.fb35	a9 00		lda #$00	    lda #0
.fb37	85 46		sta $46		    sta uint2str_remainder  ; Clear remainder
.fb39	a0 10		ldy #$10	    ldy #16                 ; 16-bit division by 10
.fb3b					div_loop:
.fb3b	06 44		asl $44		    asl uint2str_number     ; Shift left (multiplying by 2)
.fb3d	26 45		rol $45		    rol uint2str_number+1
.fb3f	26 46		rol $46		    rol uint2str_remainder  ; Shift remainder
.fb41	a5 46		lda $46		    lda uint2str_remainder
.fb43	38		sec		    sec
.fb44	e9 0a		sbc #$0a	    sbc #10                 ; Try subtracting 10
.fb46	90 04		bcc $fb4c	    bcc no_subtract         ; If borrow set, restore remainder
.fb48	85 46		sta $46		    sta uint2str_remainder
.fb4a	e6 44		inc $44		    inc uint2str_number     ; Properly store quotient
.fb4c					no_subtract:
.fb4c	88		dey		    dey
.fb4d	d0 ec		bne $fb3b	    bne div_loop            ; Loop until division is done
.fb4f	a5 46		lda $46		    lda uint2str_remainder  ; Extract digit (remainder)
.fb51	18		clc		    clc
.fb52	69 30		adc #$30	    adc #'0'                ; Convert to ASCII
.fb54	95 3e		sta $3e,x	    sta uint2str_buffer, x  ; Store digit in buffer
.fb56	ca		dex		    dex
.fb57	10 d6		bpl $fb2f	    bpl uint2str_loop       ; Keep converting
.fb59					adjust_output:
.fb59	e8		inx		    inx                     ; Move pointer to first digit
.fb5a	e0 05		cpx #$05	    cpx #5                  ; Now check against 5
.fb5c	d0 04		bne $fb62	    bne done
.fb5e	a9 30		lda #$30	    lda #'0'
.fb60	85 42		sta $42		    sta uint2str_buffer+4   ; Last character
.fb62					done:
.fb62	60		rts		    rts

;******  Return to file: extlib/extlib.asm


;******  Processing file: extlib/str2uint.asm

=$3e					str2uint_buffer  = tmp_buffer     ; 6 bytes (buffer for input string)
=$44					str2uint_result  = tmp_buffer+6   ; 2 bytes (resulting number)
=$46					str2uint_temp    = tmp_buffer+8   ; 2 bytes temporary variable
.fb63					str2uint:
.fb63	d8		cld		    cld                     ; Ensure decimal mode is off
.fb64	a9 00		lda #$00	    lda #0
.fb66	85 44		sta $44		    sta str2uint_result
.fb68	85 45		sta $45		    sta str2uint_result+1
.fb6a	a2 00		ldx #$00	    ldx #0
.fb6c					str2uint_loop:
.fb6c	b5 3e		lda $3e,x	    lda str2uint_buffer,x
.fb6e	f0 1e		beq $fb8e	    beq str2uint_end            ; null terminated
.fb70	c9 30		cmp #$30	    cmp #'0'
.fb72	90 1a		bcc $fb8e	    bcc str2uint_end            ; non-digit
.fb74	c9 3a		cmp #$3a	    cmp #'9'+1
.fb76	b0 16		bcs $fb8e	    bcs str2uint_end            ; non-digit
.fb78	48		pha		    pha
.fb79	20 8f fb	jsr $fb8f	    jsr mul10
.fb7c	68		pla		    pla
.fb7d	38		sec		    sec
.fb7e	e9 30		sbc #$30	    sbc #'0'
.fb80	18		clc		    clc
.fb81	65 44		adc $44		    adc str2uint_result
.fb83	85 44		sta $44		    sta str2uint_result
.fb85	90 02		bcc $fb89	    bcc str2uint_no_carry
.fb87	e6 45		inc $45		    inc str2uint_result+1
.fb89					str2uint_no_carry:
.fb89	e8		inx		    inx
.fb8a	e0 05		cpx #$05	    cpx #5
.fb8c	d0 de		bne $fb6c	    bne str2uint_loop
.fb8e					str2uint_end:
.fb8e	60		rts		    rts
.fb8f					mul10:
.fb8f	06 44		asl $44		    asl str2uint_result
.fb91	26 45		rol $45		    rol str2uint_result+1
.fb93	a5 44		lda $44		    lda str2uint_result
.fb95	85 46		sta $46		    sta str2uint_temp
.fb97	a5 45		lda $45		    lda str2uint_result+1
.fb99	85 47		sta $47		    sta str2uint_temp+1
.fb9b	06 44		asl $44		    asl str2uint_result
.fb9d	26 45		rol $45		    rol str2uint_result+1
.fb9f	06 44		asl $44		    asl str2uint_result
.fba1	26 45		rol $45		    rol str2uint_result+1
.fba3	18		clc		    clc
.fba4	a5 44		lda $44		    lda str2uint_result
.fba6	65 46		adc $46		    adc str2uint_temp
.fba8	85 44		sta $44		    sta str2uint_result
.fbaa	a5 45		lda $45		    lda str2uint_result+1
.fbac	65 47		adc $47		    adc str2uint_temp+1
.fbae	85 45		sta $45		    sta str2uint_result+1
.fbb0	60		rts		    rts

;******  Return to file: extlib/extlib.asm


;******  Return to file: apple1.asm


;******  Processing file: wozmon/wozmon.asm

=$24					XAML            = $24           ;  Last "opened" location Low
=$25					XAMH            = $25           ;  Last "opened" location High
=$26					STL             = $26           ;  Store address Low
=$27					STH             = $27           ;  Store address High
=$28					L               = $28           ;  Hex value parsing Low
=$29					H               = $29           ;  Hex value parsing High
=$2a					YSAV            = $2A           ;  Used to see if hex value is given
=$2b					MODE            = $2B           ;  $00=XAM, $7F=STOR, $AE=BLOCK XAM
=$0200					IN              = $0200         ;  Input buffer to $027F
=$d010					KBD             = $D010         ;  PIA.A keyboard input
=$d011					KBDCR           = $D011         ;  PIA.A keyboard control register
=$d012					DSP             = $D012         ;  PIA.B display output register
=$d013					DSPCR           = $D013         ;  PIA.B display control register
.ff00	d8		cld		WOZMON:         CLD             ; Clear decimal arithmetic mode.
.ff01	58		cli		                CLI
.ff02	a0 7f		ldy #$7f	                LDY #$7F        ; Mask for DSP data direction register.
.ff04	8c 12 d0	sty $d012	                STY DSP         ; Set it up.
.ff07	a9 a7		lda #$a7	                LDA #$A7        ; KBD and DSP control register mask.
.ff09	8d 11 d0	sta $d011	                STA KBDCR       ; Enable interrupts, set CA1, CB1, for
.ff0c	8d 13 d0	sta $d013	                STA DSPCR       ; positive edge sense/output mode.
.ff0f	c9 88		cmp #$88	NOTCR:          CMP #$88        ; BS?
.ff11	f0 13		beq $ff26	                BEQ BACKSPACE   ; Yes.
.ff13	c9 9b		cmp #$9b	                CMP #$9B        ; ESC?
.ff15	f0 03		beq $ff1a	                BEQ ESCAPE      ; Yes.
.ff17	c8		iny		                INY             ; Advance text index.
.ff18	10 0f		bpl $ff29	                BPL NEXTCHAR    ; Auto ESC if > 127.
.ff1a	a9 dc		lda #$dc	ESCAPE:         LDA #'\'+$80    ; "\".
.ff1c	20 ef ff	jsr $ffef	                JSR ECHO        ; Output it.
.ff1f	a9 8d		lda #$8d	GETLINE:        LDA #$8D        ; CR.
.ff21	20 ef ff	jsr $ffef	                JSR ECHO        ; Output it.
.ff24	a0 01		ldy #$01	                LDY #$01        ; Initialize text index.
.ff26	88		dey		BACKSPACE:      DEY             ; Back up text index.
.ff27	30 f6		bmi $ff1f	                BMI GETLINE     ; Beyond start of line, reinitialize.
.ff29	ad 11 d0	lda $d011	NEXTCHAR:       LDA KBDCR       ; Key ready?
.ff2c	10 fb		bpl $ff29	                BPL NEXTCHAR    ; Loop until ready.
.ff2e	ad 10 d0	lda $d010	                LDA KBD         ; Load character. B7 should be <80><98>1<80><99>.
.ff31	99 00 02	sta $0200,y	                STA IN,Y        ; Add to text buffer.
.ff34	20 ef ff	jsr $ffef	                JSR ECHO        ; Display character.
.ff37	c9 8d		cmp #$8d	                CMP #$8D        ; CR?
.ff39	d0 d4		bne $ff0f	                BNE NOTCR       ; No.
.ff3b	a0 ff		ldy #$ff	                LDY #$FF        ; Reset text index.
.ff3d	a9 00		lda #$00	                LDA #$00        ; For XAM mode.
.ff3f	aa		tax		                TAX             ; 0->X.
.ff40	0a		asl a		SETSTOR:        ASL             ; Leaves $7B if setting STOR mode.
.ff41	85 2b		sta $2b		SETMODE:        STA MODE        ; $00=XAM $7B=STOR $AE=BLOK XAM
.ff43	c8		iny		BLSKIP:         INY             ; Advance text index.
.ff44	b9 00 02	lda $0200,y	NEXTITEM:       LDA IN,Y        ; Get character.
.ff47	c9 8d		cmp #$8d	                CMP #$8D        ; CR?
.ff49	f0 d4		beq $ff1f	                BEQ GETLINE     ; Yes, done this line.
.ff4b	c9 ae		cmp #$ae	                CMP #'.'+$80    ; "."?
.ff4d	90 f4		bcc $ff43	                BCC BLSKIP      ; Skip delimiter.
.ff4f	f0 f0		beq $ff41	                BEQ SETMODE     ; Yes. Set STOR mode.
.ff51	c9 ba		cmp #$ba	                CMP #':'+$80    ; ":"?
.ff53	f0 eb		beq $ff40	                BEQ SETSTOR     ; Yes. Set STOR mode.
.ff55	c9 d2		cmp #$d2	                CMP #'R'+$80    ; "R"?
.ff57	f0 3b		beq $ff94	                BEQ RUN         ; Yes. Run user program.
.ff59	86 28		stx $28		                STX L           ; $00-> L.
.ff5b	86 29		stx $29		                STX H           ; and H.
.ff5d	84 2a		sty $2a		                STY YSAV        ; Save Y for comparison.
.ff5f	b9 00 02	lda $0200,y	NEXTHEX:        LDA IN,Y        ; Get character for hex test.
.ff62	49 b0		eor #$b0	                EOR #$B0        ; Map digits to $0-9.
.ff64	c9 0a		cmp #$0a	                CMP #$0A        ; Digit?
.ff66	90 06		bcc $ff6e	                BCC DIG         ; Yes.
.ff68	69 88		adc #$88	                ADC #$88        ; Map letter "A"-"F" to $FA-FF.
.ff6a	c9 fa		cmp #$fa	                CMP #$FA        ; Hex letter?
.ff6c	90 11		bcc $ff7f	                BCC NOTHEX      ; No, character not hex.
.ff6e	0a		asl a		DIG:            ASL
.ff6f	0a		asl a		                ASL             ; Hex digit to MSD of A.
.ff70	0a		asl a		                ASL
.ff71	0a		asl a		                ASL
.ff72	a2 04		ldx #$04	                LDX #$04        ; Shift count.
.ff74	0a		asl a		HEXSHIFT:       ASL             ; Hex digit left, MSB to carry.
.ff75	26 28		rol $28		                ROL L           ; Rotate into LSD.
.ff77	26 29		rol $29		                ROL H           ;  Rotate into MSD<80><99>s.
.ff79	ca		dex		                DEX             ; Done 4 shifts?
.ff7a	d0 f8		bne $ff74	                BNE HEXSHIFT    ; No, loop.
.ff7c	c8		iny		                INY             ; Advance text index.
.ff7d	d0 e0		bne $ff5f	                BNE NEXTHEX     ; Always taken. Check next char for hex.
.ff7f	c4 2a		cpy $2a		NOTHEX:         CPY YSAV        ; Check if L, H empty (no hex digits).
.ff81	f0 97		beq $ff1a	                BEQ ESCAPE      ; Yes, generate ESC sequence.
.ff83	24 2b		bit $2b		                BIT MODE        ; Test MODE byte.
.ff85	50 10		bvc $ff97	                BVC NOTSTOR     ;  B6=0 STOR 1 for XAM & BLOCK XAM
.ff87	a5 28		lda $28		                LDA L           ; LSD<80><99>s of hex data.
.ff89	81 26		sta ($26,x)	                STA (STL,X)     ; Store at current <80><98>store index<80><99>.
.ff8b	e6 26		inc $26		                INC STL         ; Increment store index.
.ff8d	d0 b5		bne $ff44	                BNE NEXTITEM    ; Get next item. (no carry).
.ff8f	e6 27		inc $27		                INC STH         ; Add carry to <80><98>store index<80><99> high order.
.ff91	4c 44 ff	jmp $ff44	TONEXTITEM:     JMP NEXTITEM    ; Get next command item.
.ff94	6c 24 00	jmp ($0024)	RUN:            JMP (XAML)      ; Run at current XAM index.
.ff97	30 2b		bmi $ffc4	NOTSTOR:        BMI XAMNEXT     ; B7=0 for XAM, 1 for BLOCK XAM.
.ff99	a2 02		ldx #$02	                LDX #$02        ; Byte count.
.ff9b	b5 27		lda $27,x	SETADR:         LDA L-1,X       ; Copy hex data to
.ff9d	95 25		sta $25,x	                STA STL-1,X     ; <80><98>store index<80><99>.
.ff9f	95 23		sta $23,x	                STA XAML-1,X    ; And to <80><98>XAM index<80><99>.
.ffa1	ca		dex		                DEX             ; Next of 2 bytes.
.ffa2	d0 f7		bne $ff9b	                BNE SETADR      ; Loop unless X=0.
.ffa4	d0 14		bne $ffba	NXTPRNT:        BNE PRDATA      ; NE means no address to print.
.ffa6	a9 8d		lda #$8d	                LDA #$8D        ; CR.
.ffa8	20 ef ff	jsr $ffef	                JSR ECHO        ; Output it.
.ffab	a5 25		lda $25		                LDA XAMH        ; <80><98>Examine index<80><99> high-order byte.
.ffad	20 dc ff	jsr $ffdc	                JSR PRBYTE      ; Output it in hex format.
.ffb0	a5 24		lda $24		                LDA XAML        ; Low-order <80><98>examine index<80><99> byte.
.ffb2	20 dc ff	jsr $ffdc	                JSR PRBYTE      ; Output it in hex format.
.ffb5	a9 ba		lda #$ba	                LDA #':'+$80    ; ":".
.ffb7	20 ef ff	jsr $ffef	                JSR ECHO        ; Output it.
.ffba	a9 a0		lda #$a0	PRDATA:         LDA #$A0        ; Blank.
.ffbc	20 ef ff	jsr $ffef	                JSR ECHO        ; Output it.
.ffbf	a1 24		lda ($24,x)	                LDA (XAML,X)    ; Get data byte at <80><98>examine index<80><99>.
.ffc1	20 dc ff	jsr $ffdc	                JSR PRBYTE      ; Output it in hex format.
.ffc4	86 2b		stx $2b		XAMNEXT:        STX MODE        ; 0->MODE (XAM mode).
.ffc6	a5 24		lda $24		                LDA XAML
.ffc8	c5 28		cmp $28		                CMP L           ; Compare <80><98>examine index<80><99> to hex data.
.ffca	a5 25		lda $25		                LDA XAMH
.ffcc	e5 29		sbc $29		                SBC H
.ffce	b0 c1		bcs $ff91	                BCS TONEXTITEM  ; Not less, so no more data to output.
.ffd0	e6 24		inc $24		                INC XAML
.ffd2	d0 02		bne $ffd6	                BNE MOD8CHK     ; Increment <80><98>examine index<80><99>.
.ffd4	e6 25		inc $25		                INC XAMH
.ffd6	a5 24		lda $24		MOD8CHK:        LDA XAML        ; Check low-order <80><98>examine index<80><99> byte
.ffd8	29 07		and #$07	                AND #$07        ; For MOD 8=0
.ffda	10 c8		bpl $ffa4	                BPL NXTPRNT     ; Always taken.
.ffdc	48		pha		PRBYTE:         PHA             ; Save A for LSD.
.ffdd	4a		lsr a		                LSR
.ffde	4a		lsr a		                LSR
.ffdf	4a		lsr a		                LSR             ; MSD to LSD position.
.ffe0	4a		lsr a		                LSR
.ffe1	20 e5 ff	jsr $ffe5	                JSR PRHEX       ; Output hex digit.
.ffe4	68		pla		                PLA             ; Restore A.
.ffe5	29 0f		and #$0f	PRHEX:          AND #$0F        ; Mask LSD for hex print.
.ffe7	09 b0		ora #$b0	                ORA #'0'+$80    ; Add "0".
.ffe9	c9 ba		cmp #$ba	                CMP #$BA        ; Digit?
.ffeb	90 02		bcc $ffef	                BCC ECHO        ; Yes, output it.
.ffed	69 06		adc #$06	                ADC #$06        ; Add offset for letter.
.ffef	2c 12 d0	bit $d012	ECHO:           BIT DSP         ; bit (B7) cleared yet?
.fff2	30 fb		bmi $ffef	                BMI ECHO        ; No, wait for display.
.fff4	8d 12 d0	sta $d012	                STA DSP         ; Output character. Sets DA.
.fff7	60		rts		                RTS             ; Return.
.fff8	40		rti		 NMI:           RTI             ; simple Interrupt Service Routine(ISR)
.fff9	40		rti		 IRQ:           RTI             ; simple Interrupt Service Routine(ISR)
>fffa	f8 ff				    .WORD NMI            ; NMI
>fffc	00 ff				    .WORD RESET          ; RESET
>fffe	f9 ff				    .WORD IRQ            ; BRK/IRQ

;******  Return to file: apple1.asm


;******  End of listing
